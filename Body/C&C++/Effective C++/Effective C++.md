## 《Effective C++》

------

条款1
---

- C++是个多重泛型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。
- 如果一个新对象被定义，一定会有个构造函数被调用，不可能调用赋值操作。例如A a1 = a2;

条款2
---
- 如果声明式中的变量是class专属常量又是static且为整数类型(int,char,bool)，只要不取地址，可以声明并使用它而无须提供定义式。例如类体中使用“static const int n = 5;”语句。
- 枚举类型在C#或C++,java,VB等一些计算机编程语言中是一种基本数据类型而不是构造数据类型，而在C语言等计算机编程语言中是一种构造数据类型。

条款3
---
- void f1(const int * n);与void f2(int const * n)；意思是一样的。
- 迭代器中const的用法
```c++
std::vector<int> vec;
...
const std::vector<int>::iterator iter = vec.begin();     //iter的作用像个T* const
*iter = 10;     //没问题，改变iter所指物
++iter;         //错误！iter是const
std::vector<int>::const_iterator cIter = vec.begin();    //cIter的作用域像个const T*
*cIter = 10;    //错误！*cIter是const
++cIter;        //没问题，改变cIter
```
- a =( c++,b++)；→ a = b; c++; b++;<br>
按照运算符的优先级，先计算括号,也就是讨论c++,b++。然后计算++，也就是c和b分别自加。然后谈论逗号运算符，没有意义，就是从左到右。所以最后赋值给a的是b++。前面提到一个注意就是，虽然b自加了，但是他的写法是b++ 而不是++ b，意义上是先使用后自加。所以赋值给a的值是当前的b的值，这一行指令结束以后，b自身的值才会++。
- mutable的用法

```c++
class CTextBlock{
public:
    ...
    size_t length() const;
private:
    char* pText;
    mutable size_t textLength;  //这些成员变量可能总是会被更改，即使在const成员函数内
    mutable bool lengthIsValid;
};
size_t CTextBlock::length() const
{
    if(!lengthIsValid)
    {
        textLength = strlen(pText); //正确，允许值得修改
        lengthIsValid = true;
    }
    return textLength;
}
```

条款4
---
- 比起先调用default构造函数再调用赋值操作，单只调用一次赋值构造函数更加高效。对于内置型对象，其初始化和赋值成本相同，但为了一致性最好也通过成员初值列来初始化。

条款5
---
- C++不允许让引用改指向不同对象。
- 内含引用成员或const成员的类，必须自己定义赋值运算符。
- 如果某个父类将赋值运算符声明为private，编译器将拒绝自动为其子类生成赋值运算符。

条款6
---
- 为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。或者继承像uncopyable这样的父类也是一种做法。

条款7
---
- 如果类中含有virtual函数，其对象的体积会增加，并且不再具有移植性。
- 所有的stl容器都不带virtual函数，不应该被其他类继承。
- 可以通过将析构函数声明为纯虚函数的方式创建抽象类，但必须为纯虚析构函数提供一份定义。

条款8
---
- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或结束程序。

条款9
---
- 在构造和析构期间不要调用virtual函数，因为此时子类还未初始化，只会错误地执行父类的virtual函数。

条款10
---
- 重载赋值运算符时最好返回*this的引用。

条款11
---
- 使用证同测试来处理自我赋值。

```c++
    if (this == rhs) return *this;
```

条款12
---
- 子类调用父类赋值运算符操作的语句。
```c++
    BaseClassName::operator=(rhs);
```
- 如果复制构造函数和重载赋值运算符有相近的代码，可以建立一个新的成员函数被两者调用以消除重复代码。这样的函数往往是private而且常被命名为init。

条款13
---
- 为防止资源泄漏，以对象管理资源，资源取得时机便是初始化时机。比如使用智能指针管理动态分配的内存。
- [智能指针](https://blog.csdn.net/zy19940906/article/details/50470087)

条款14
---
- shared_ptr允许指定所谓的删除器，那是一个函数或函数对象，当引用次数为0时被调用。删除器是可有可无的第二参数。
- [智能指针删除器](https://blog.csdn.net/caroline_wendy/article/details/16938707)
- [函数指针](https://2cto.com/kf/201707/654539.html)

条款15
---
- [operator隐式类型转换](https://www.cnblogs.com/jeanschen/archive/2013/07/31/3227385.html)

条款16
---
- 尽量不要对动态数组做typedef操作。
```
typedef string s[4];
string * ps = new s;    //等于new s[4]
delete [] ps;           //以数组方式delete
```

条款17
---
- C++不以特定次序完成函数参数的核算。
- 用独立语句将新建对象放入智能指针内，可以防止难以察觉的资源泄露出现。

条款18
---
- 阻止接口误用的方法包括建立新类型，限制类型上的操作，束缚对象值以及消除客户的资源管理责任（自动管理资源）。

条款19
---
- 类设计时应该考虑的问题。

条款20
---
- 以引用的方式传递参数可以避免对象切割问题。
- 对于内置类型，传值比传引用效率更高。

条款21
---
- 对于临时对象或new生成的对象，不应该返回其引用。

条款22
---
- private才能实现类的封装性。
- protected并不比public更具封装性。

条款23
---
- 用非成员函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性。

条款24
---
- 如果某个函数所有参数（包括被this指针所指的那个隐喻参数）都可能进行类型转换，则应该将这个函数设置为非成员函数。

条款25
---
- C++只允许对类模板偏特化，函数模板不允许偏特化。
- 可以全特化std内的模板，但不可以添加新的模板（或类或方法或其他）到std里面。

条款26
---
- 除非赋值成本比“构造+析构”成本低，不然将临时变量定义于循环内效率更高。

条款27
---
- 旧式转型
```c++
(类型)表达式  //c风格
类型(表达式)  //函数风格
```
- 新式转型
```c++
const_cast<类型>(表达式)    //移除对象的const属性
dynamic_cast<类型>(表达式)  //决定某对象是否归属继承体系中的某个类型，耗费重大运行成本
reinterpret_cast<类型>(表达式)  //执行低级转型，如将int指针转为int，不可移植
static_cast<类型>(表达式)   //强迫隐式转换，如将非常量转为常量，int转为double等。但无法将const属性移除
```
- 编程尽量避免转型。如果必要，最好使用新式转型，不要使用旧式转型。

条款28
---
- 避免返回指向对象内部的引用，指针以及迭代器，这能增加封装性，防止所指资源被意外释放。

条款29
---
- 强烈异常安全保证的函数往往能通过拷贝加交换的形式实现，但为此付出的效率代价也值得考虑。
- 函数的异常安全等级通常只等于其调用的各个函数中最弱的那一个。

条款30
---
- 类内定义的成员函数与友元函数，都被隐喻声明为inline。
- 所有virtual函数都不支持inline。
- inline的本质是对此函数的每一个调用都以函数本体替换之。

条款31
---
- 头文件一旦修改，所有包含该头文件的代码文件都会重新编译。
- 编译依存性最小化的两种方法：
    1. 将类分割成两部分，一部分提供接口，一部分负责具体实现。
    2. 使用纯虚函数将类定义为抽象基类。

条款32
---
- pulic继承等同于“是一个”概念。适用基类的操作一定也适用于此方法继承的子类。

条款33
---
- 子类的变量，函数名会掩盖基类中的相同名称成员。基类中的多个重载函数会全部被子类同名成员覆盖。
- 使用using可以让子类访问到被覆盖的基类成员函数。

条款34
---
- C++允许为纯虚函数提供定义，但调用它的唯一途径是“调用时你明确指出其类名”。
- 虚函数在子类中允许缺省，纯虚函数在子类中必须重新定义。

条款35
---
- [Private类型虚函数](https://blog.csdn.net/sony303/article/details/5815984)

条款36
---
- 绝对不要重新定义继承而来的非虚函数。

条款37
---
- 绝对不要重新定义一个继承而来的缺省参数值。