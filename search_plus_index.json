{"./":{"url":"./","title":"序","keywords":"","body":"序 名称：《Revery》 作者：  Ryou To make a prairie, it takes a clover and one bee. Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-20 21:38:29 "},"Body/理论/计算机网络/基础.html":{"url":"Body/理论/计算机网络/基础.html","title":"计算机网络","keywords":"","body":"基础 计算机网络基础知识 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/基础/基础.html":{"url":"Body/C&C++/基础/基础.html","title":"基础","keywords":"","body":"基础 内置基本类型 左值、右值、左值引用、右值引用 static成员的初始化和特点 静态局部变量只对定义它的函数体始终可见，函数体执行完后虽然还存在，但无法被其他的使用。 class默认的是private继承。struct则相反，默认的是public继承。 宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响。 对变量声明一个引用，并不另开辟内存单元，x和y都代表相同一变量存储单元。在声明一个引用时，必须同时使之初始化。在函数中声明一个变量的引用后，在函数执行期间，该引用一直与其代表的变量相联系，不能再作为其他变量的别名。 常引用就是用const对引用加以限定，表示不允许改变该引用的值。例如： int a = 6; // 定义整型变量a，初值为6 const int &b = a; // 声明常引用，不允许改变b的值 b = 8; // 改变常引用b的值，错误 a = 8; // 改变a的值，正确 enum枚举量声明、定义、使用 未定义行为 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/基础/数组.html":{"url":"Body/C&C++/基础/数组.html","title":"数组","keywords":"","body":"数组 数组名代表被分配的内存首地址，是一个地址常量，不能作为左值，无法进行赋值。 数组引用 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/基础/运算符.html":{"url":"Body/C&C++/基础/运算符.html","title":"运算符","keywords":"","body":"运算符 只能使用成员函数重载的运算符有：=、()、[]、->、new、delete。 运算符重载 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/基础/函数.html":{"url":"Body/C&C++/基础/函数.html","title":"函数","keywords":"","body":"函数 函数的隐含储存类型是extern，函数的形参或变量的存储类型为auto。 C++允许给形参提供默认值，默认参数应在函数名第一次出现时指定。默认参数必须是函数参数表中最右边(尾部)的参数。 std::function和std::bind 标准C++ 要求main()函数必须声明为int型。有的操作系统(如Linux)要求执行一个程序后必须向操作系统返回一个数值。但有些C++ 编译系统并未完全执行C++这一规定，如主函数首行写成“void main()”也能通过。 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/基础/指针.html":{"url":"Body/C&C++/基础/指针.html","title":"指针","keywords":"","body":"指针 智能指针 自定义删除器 不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr。 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/基础/类.html":{"url":"Body/C&C++/基础/类.html","title":"类","keywords":"","body":"类 用关键字const来声明常数据成员。常数据成员只能通过构造函数的参数初始化表进行初始化。 常对象只能调用常成员函数，非常对象既可以调用非常成员函数，也可以调用常成员函数。 在类内可以直接访问所有的静态数据成员，类的静态数据成员必须在类外进行初始化，初始化方式为： 类型名 类名::静态数据成员名 = 初始值; 虚基类的构造函数先于非虚基类的构造函数执行。 指针指向一个具体对象后，不能通过指针直接或间接调用构造函数，所以C++还规定构造函数也不能声明为虚函数。 如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都是有默认值，则此构造函数是拷贝构造函数。 虚函数与析构函数 #include using namespace std; class M{ public: M(){cout 类的继承 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/进阶/I&O.html":{"url":"Body/C&C++/进阶/I&O.html","title":"进阶","keywords":"","body":"I/O 调用python //初始化python Py_Initialize（）； if（！Py_IsInitialized（）) { return; } PyRun_SimpleString(“import sys”); PyRun_SimpleString(“sys.path.append(‘.’)”); PyObject* pModule = PyImport_ImportModule(“模块名称”); if(!pModule) { return; } PyObject* pFunc = PyObject_GetAttrString(pModule,”方法名称”); if(!pFunc) { return; } /* s 表示字符串 i 表示整型变量 f 表示浮点变量 o 表示python对象 */ PyObject* pArgs = PyTuple_New(2); PyTuple_SetItem(pArgs, 0, Py_BuildValue(“s”, “参数1”.toStdString().c_str())); PyTuple_SetItem(pArgs, 1, Py_BuildValue(“s”, “参数2”.toStdString().c_str())); PyObject* object = PyObject_Callobject(pFunc, pArgs); int result = -1; PyArg_Parse(object, “i”, &result); //转化调用结果 //结束，释放python Py_Finalize(); ini文件 QSettings configIni(“文件名.ini”, QSettings::IniFrmat); //读 QString value = configIni.value(“组名/属性名”).toString(); //写 configIni.beginGroup(“组名”); configIni.setValue(“属性名”, 属性值); xml文件 #include #include 解析xml QFile xmlFile(“文件名”); if(!xmlFile.exists()) { return false; } if(!xmlFile.open(QFile::ReadOnly)) { return false; } QDomDocument doc; if(!doc.setContent(&xmlFile)) { return false; } QDomElement root = doc.documentElement(); if(root.tagName() != “一级节点名称”) { return false; } QDomNode node = root.firstChild(); if(node.isNull) { return false; } QDomNode childNode = node.firstChild(); //访问子节点 QDomNode siblingNode = node.nextSibling(); //访问同级节点 QString tagName = node.toElement().tagName(); //当前节点名称 QString text = node.toElement().text(); //当前节点文本内容 QString attributeValue = node.toElement().attribute(“属性名”); //当前节点属性值 xmlFile.close(); 生成xml QDomDocument doc; //设置前缀 QString strHeader(”version=\\”1.0\\” encoding=\\”UTF-8\\””); doc.appendChild(doc.createProcessingInstruction(“xml”, strHeader)); QDomElement element = doc.createElement(“节点名称”); //创建的节点名称 element.setAttribbute(“属性名”, 属性值(字符串)); //设置节点属性 QDomText text = doc.createTextNode(“文本内容”); //设置文本内容 element.appendChild(text); doc.appendChild(element); //连接子节点 QFile file(“文件名”); if(!file.open(QIODevice::WriteOnly)) { return false; } QTextstream stream(&file); doc.save(stream, 4); file.close(); dll文件 #include 生成dll #ifndef 文件名_EXPORTS #define 文件名_EXPORTS __declspec(dllexport) #endif #ifdef __cplusplus extern “C” { #endif ... #ifdef __cplusplus } #endif 动态调用 typedef 返回类型 (*PtrFunc)(参数); HMODULE hDll = LoadLibrary(L”文件名.dll”); if(hDll != NULL) { PtrFunc pFunc = (PtrFunc)GetProcAddress(hDll, “方法名”); if(pFunc != NULL) { pFunc(参数); } } Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/进阶/异常处理.html":{"url":"Body/C&C++/进阶/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-09-04 15:54:22 "},"Body/C&C++/进阶/拓展.html":{"url":"Body/C&C++/进阶/拓展.html","title":"拓展","keywords":"","body":"拓展 lambda表达式 tr1::function Google C++ 编码规范 C++面试常见问题 C++ Socket编程 C++高级特性介绍 位运算 框架与库 避免内存泄漏 C++资源 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/算法/基础.html":{"url":"Body/C&C++/算法/基础.html","title":"算法","keywords":"","body":"基础 数据结构和算法动态可视化 经典排序算法 堆排序 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/算法/冒泡排序.html":{"url":"Body/C&C++/算法/冒泡排序.html","title":"冒泡排序","keywords":"","body":"冒泡排序 template bool up(T a, T b) //a_rank b; } template bool down(T a, T b) { return a void bubble_sort(T array[], int lo, int hi, bool(*cmp)(T, T)) { int last = hi; for(bool sorted = false;sorted = !sorted;hi = last) for (int i = lo+1; i Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/C&C++/STL/toc.html":{"url":"Body/C&C++/STL/toc.html","title":"STL","keywords":"","body":"目录 attribute filesystem future initializer_list Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-11-27 16:36:11 "},"Body/C&C++/STL/attribute.html":{"url":"Body/C&C++/STL/attribute.html","title":"attribute","keywords":"","body":"attribute noreturn 指示函数不返回。 此属性仅应用到函数声明中正在声明的函数名。若拥有此属性的函数实际上返回，则行为未定义。 若函数的任何声明指定此属性，则其首个声明必须指定它。若函数在一个翻译单元中声明为带 [[noreturn]] 属性，而同一函数在另一翻译单元中声明为不带 [[noreturn]] 属性，则程序非良构；不要求诊断。 [[ noreturn ]] void f() { throw \"error\"; // OK } void q [[ noreturn ]] (int i) { // 若以 0) { throw \"positive\"; } } // void h() [[noreturn]]; // 错误：属性应用到 h 的函数类型，而非 h 自身 deprecated 指示允许使用声明有此属性的名称或实体，但因故不鼓励使用。编译器通常会对其使用情况发出警告。若指定了 字符串字面量，则它通常被包含于警告中。 声明时未弃用的名字可被重声明为 deprecated。声明为 deprecated 的名字不能通过重声明它而不带此属性变为未弃用。 #include [[deprecated]] void TriassicPeriod() { std::clog fallthrough 指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。 仅可应用到空语句以创建直落语句（ fallthrough statement ）： [[fallthrough]]; 。 直落语句仅可用于 switch 语句中，其中待执行的下个语句是该 switch 语句的带 case 或 default 标号的语句。若直落语句在循环中，则下个（带标号）语句必须是该循环的同一迭代的一部分。 指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。 void f(int n) { void g(), h(), i(); switch (n) { case 1: case 2: g(); [[fallthrough]]; case 3: // 直落时不警告 h(); case 4: // 编译器可在发生直落时警告 if(n nodiscard 鼓励编译器在返回值被舍弃时发布警告。 若从并非转型到 void 的弃值表达式中，调用声明为 nodiscard 的函数，或调用按值返回声明为 nodiscard 的枚举或类的函数，则鼓励编译器发布警告。 struct [[nodiscard]] error_info { }; struct [[nodiscard(\"reason\")]] error_info1 { }; error_info enable_missile_safety_mode(); void test_missiles() { enable_missile_safety_mode(); // 编译器可在舍弃 nodiscard 值时发布警告 } error_info1& foo(); void f1() { foo(); // 并非按值返回 nodiscard 类型，无警告 } maybe_unused 抑制针对未使用实体的警告。 #include [[maybe_unused]] void f([[maybe_unused]] bool thing1, [[maybe_unused]] bool thing2) { [[maybe_unused]] bool b = thing1 && thing2; assert(b); // 发行模式中，assert 在编译中被去掉，因而未使用 b // 无警告，因为它被声明为 [[maybe_unused]] } // 未使用参数 thing1 与 thing2，无警告 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-11-27 16:36:24 "},"Body/C&C++/STL/filesystem.html":{"url":"Body/C&C++/STL/filesystem.html","title":"filesystem","keywords":"","body":"filesystem #include std::filesystem::path path(\"路径\"); if(!std::filesystem::exists(path)) { // 异常处理 } std::filesystem::directory_entry dir(path); if(!dir.is_directory()) { // 异常处理 } // 递归遍历至最深层路径 for(const auto& entry : std::filesystem::recursive_directory_iterator(dir)) { // 文件 if(entry.is_regular_file()) { // ... } // 文件夹 if(entry.is_directory()) { // ... } } 目录操作(c++17) #include // 位于std::filesystem命名空间下 void copy(const path& from, const path& to) ：目录复制 path absolute(const path& pval, const path& base = current_path()) ：获取相对于base的绝对路径 bool create_directory(const path& pval) ：当目录不存在时创建目录 bool create_directories(const path& pval) ：形如/a/b/c这样的，如果都不存在，创建目录结构 bool exists(const path& pval) ：用于判断path是否存在 uintmax_t file_size(const path& pval) ：返回目录的大小 file_time_type last_write_time(const path& pval) ：返回目录最后修改日期的file_time_type对象 bool remove(const path& pval) ：删除目录 uintmax_t remove_all(const path& pval) ：递归删除目录下所有文件，返回被成功删除的文件个数 void rename(const path& from, const path& to) ：移动文件或者重命名 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-11-27 16:38:25 "},"Body/C&C++/STL/future.html":{"url":"Body/C&C++/STL/future.html","title":"future","keywords":"","body":"future #include promise #include #include #include #include #include #include void accumulate(std::vector::iterator first, std::vector::iterator last, std::promise accumulate_promise) { int sum = std::accumulate(first, last, 0); accumulate_promise.set_value(sum); // 提醒 future } void do_work(std::promise barrier) { std::this_thread::sleep_for(std::chrono::seconds(1)); barrier.set_value(); } int main() { // 演示用 promise 在线程间传递结果。 std::vector numbers = { 1, 2, 3, 4, 5, 6 }; std::promise accumulate_promise; std::future accumulate_future = accumulate_promise.get_future(); std::thread work_thread(accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise)); // future::get() 将等待直至该 future 拥有合法结果并取得它 // 无需在 get() 前调用 wait() //accumulate_future.wait(); // 等待结果 std::cout 在线程间对状态发信号 std::promise barrier; std::future barrier_future = barrier.get_future(); std::thread new_work_thread(do_work, std::move(barrier)); barrier_future.wait(); new_work_thread.join(); } output: result=21 packaged_task #include #include #include #include #include int f(int x, int y) { return std::pow(x,y); } void task_lambda() { std::packaged_task task([](int a, int b) { return std::pow(a, b); }); std::future result = task.get_future(); task(2, 9); std::cout task(std::bind(f, 2, 11)); std::future result = task.get_future(); task(); std::cout task(f); std::future result = task.get_future(); std::thread task_td(std::move(task), 2, 10); task_td.join(); std::cout output: task_lambda: 512 task_bind: 2048 task_thread: 1024 async #include #include #include #include #include #include #include std::mutex m; struct X { void foo(int i, const std::string& str) { std::lock_guard lk(m); std::cout lk(m); std::cout lk(m); std::cout int parallel_sum(RandomIt beg, RandomIt end) { auto len = end - beg; if (len , mid, end); int sum = parallel_sum(beg, mid); return sum + handle.get(); } int main() { std::vector v(10000, 1); std::cout output: The sum is 10000 43 world! 53 Hello 42 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-11-27 16:39:43 "},"Body/C&C++/STL/initializer_list.html":{"url":"Body/C&C++/STL/initializer_list.html","title":"initializer_list","keywords":"","body":"initializer_list #include #include #include #include template struct S { std::vector v; S(std::initializer_list l) : v(l) { std::cout l) { v.insert(v.end(), l.begin(), l.end()); } std::pair c_arr() const { return {&v[0], v.size()}; // 在 return 语句中复制列表初始化 /*这里的返回值不能使用 std::initializer_list。std::initializer_list 的内部并不负责保存初始化列表中元素的拷贝,仅仅存储了列表中元素的引用而已，因此需要再持有对象的生存周期之前传递完毕*/ } }; template void templated_fn(T) {} int main() { S s = {1, 2, 3, 4, 5}; // 复制初始化 s.append({6, 7, 8}); // 函数调用中的列表初始化 std::cout >({1, 2, 3}); // OK templated_fn>({1, 2, 3}); // 也 OK } output: constructed with a 5-element list The vector size is now 8 ints: 1 2 3 4 5 6 7 8 Range-for over brace-init-list: -1 -2 -3 The list bound to auto has size() = 3 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-11-27 16:40:31 "},"Body/C&C++/Effective C++/Effective C++.html":{"url":"Body/C&C++/Effective C++/Effective C++.html","title":"Effective C++","keywords":"","body":"《Effective C++》 条款1 C++是个多重泛型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。 如果一个新对象被定义，一定会有个构造函数被调用，不可能调用赋值操作。例如A a1 = a2; 条款2 如果声明式中的变量是class专属常量又是static且为整数类型(int,char,bool)，只要不取地址，可以声明并使用它而无须提供定义式。例如类体中使用“static const int n = 5;”语句。 枚举类型在C#或C++,java,VB等一些计算机编程语言中是一种基本数据类型而不是构造数据类型，而在C语言等计算机编程语言中是一种构造数据类型。 条款3 void f1(const int n);与void f2(int const n)；意思是一样的。 迭代器中const的用法std::vector vec; ... const std::vector::iterator iter = vec.begin(); //iter的作用像个T* const *iter = 10; //没问题，改变iter所指物 ++iter; //错误！iter是const std::vector::const_iterator cIter = vec.begin(); //cIter的作用域像个const T* *cIter = 10; //错误！*cIter是const ++cIter; //没问题，改变cIter a =( c++,b++)；→ a = b; c++; b++; 按照运算符的优先级，先计算括号,也就是讨论c++,b++。然后计算++，也就是c和b分别自加。然后谈论逗号运算符，没有意义，就是从左到右。所以最后赋值给a的是b++。前面提到一个注意就是，虽然b自加了，但是他的写法是b++ 而不是++ b，意义上是先使用后自加。所以赋值给a的值是当前的b的值，这一行指令结束以后，b自身的值才会++。 mutable的用法 class CTextBlock{ public: ... size_t length() const; private: char* pText; mutable size_t textLength; //这些成员变量可能总是会被更改，即使在const成员函数内 mutable bool lengthIsValid; }; size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = strlen(pText); //正确，允许值得修改 lengthIsValid = true; } return textLength; } 条款4 比起先调用default构造函数再调用赋值操作，单只调用一次赋值构造函数更加高效。对于内置型对象，其初始化和赋值成本相同，但为了一致性最好也通过成员初值列来初始化。 条款5 C++不允许让引用改指向不同对象。 内含引用成员或const成员的类，必须自己定义赋值运算符。 如果某个父类将赋值运算符声明为private，编译器将拒绝自动为其子类生成赋值运算符。 条款6 为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。或者继承像uncopyable这样的父类也是一种做法。 条款7 如果类中含有virtual函数，其对象的体积会增加，并且不再具有移植性。 所有的stl容器都不带virtual函数，不应该被其他类继承。 可以通过将析构函数声明为纯虚函数的方式创建抽象类，但必须为纯虚析构函数提供一份定义。 条款8 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或结束程序。 条款9 在构造和析构期间不要调用virtual函数，因为此时子类还未初始化，只会错误地执行父类的virtual函数。 条款10 重载赋值运算符时最好返回*this的引用。 条款11 使用证同测试来处理自我赋值。 if (this == rhs) return *this; 条款12 子类调用父类赋值运算符操作的语句。 BaseClassName::operator=(rhs); 如果复制构造函数和重载赋值运算符有相近的代码，可以建立一个新的成员函数被两者调用以消除重复代码。这样的函数往往是private而且常被命名为init。 条款13 为防止资源泄漏，以对象管理资源，资源取得时机便是初始化时机。比如使用智能指针管理动态分配的内存。 智能指针 条款14 shared_ptr允许指定所谓的删除器，那是一个函数或函数对象，当引用次数为0时被调用。删除器是可有可无的第二参数。 智能指针删除器 函数指针 条款15 operator隐式类型转换 条款16 尽量不要对动态数组做typedef操作。typedef string s[4]; string * ps = new s; //等于new s[4] delete [] ps; //以数组方式delete 条款17 C++不以特定次序完成函数参数的核算。 用独立语句将新建对象放入智能指针内，可以防止难以察觉的资源泄露出现。 条款18 阻止接口误用的方法包括建立新类型，限制类型上的操作，束缚对象值以及消除客户的资源管理责任（自动管理资源）。 条款19 类设计时应该考虑的问题。 条款20 以引用的方式传递参数可以避免对象切割问题。 对于内置类型，传值比传引用效率更高。 条款21 对于临时对象或new生成的对象，不应该返回其引用。 条款22 private才能实现类的封装性。 protected并不比public更具封装性。 条款23 用非成员函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性。 条款24 如果某个函数所有参数（包括被this指针所指的那个隐喻参数）都可能进行类型转换，则应该将这个函数设置为非成员函数。 条款25 C++只允许对类模板偏特化，函数模板不允许偏特化。 可以全特化std内的模板，但不可以添加新的模板（或类或方法或其他）到std里面。 条款26 除非赋值成本比“构造+析构”成本低，不然将临时变量定义于循环内效率更高。 条款27 旧式转型(类型)表达式 //c风格 类型(表达式) //函数风格 新式转型const_cast(表达式) //移除对象的const属性 dynamic_cast(表达式) //决定某对象是否归属继承体系中的某个类型，耗费重大运行成本 reinterpret_cast(表达式) //执行低级转型，如将int指针转为int，不可移植 static_cast(表达式) //强迫隐式转换，如将非常量转为常量，int转为double等。但无法将const属性移除 编程尽量避免转型。如果必要，最好使用新式转型，不要使用旧式转型。 条款28 避免返回指向对象内部的引用，指针以及迭代器，这能增加封装性，防止所指资源被意外释放。 条款29 强烈异常安全保证的函数往往能通过拷贝加交换的形式实现，但为此付出的效率代价也值得考虑。 函数的异常安全等级通常只等于其调用的各个函数中最弱的那一个。 条款30 类内定义的成员函数与友元函数，都被隐喻声明为inline。 所有virtual函数都不支持inline。 inline的本质是对此函数的每一个调用都以函数本体替换之。 条款31 头文件一旦修改，所有包含该头文件的代码文件都会重新编译。 编译依存性最小化的两种方法： 将类分割成两部分，一部分提供接口，一部分负责具体实现。 使用纯虚函数将类定义为抽象基类。 条款32 pulic继承等同于“是一个”概念。适用基类的操作一定也适用于此方法继承的子类。 条款33 子类的变量，函数名会掩盖基类中的相同名称成员。基类中的多个重载函数会全部被子类同名成员覆盖。 使用using可以让子类访问到被覆盖的基类成员函数。 条款34 C++允许为纯虚函数提供定义，但调用它的唯一途径是“调用时你明确指出其类名”。 虚函数在子类中允许缺省，纯虚函数在子类中必须重新定义。 条款35 Private类型虚函数 条款36 绝对不要重新定义继承而来的非虚函数。 条款37 绝对不要重新定义一个继承而来的缺省参数值。 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/Linux/Linux.html":{"url":"Body/Linux/Linux.html","title":"Linux","keywords":"","body":"Linux linux命令大全 gdb教程 vim命令 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/Python/Python.html":{"url":"Body/Python/Python.html","title":"Python","keywords":"","body":"Python C++调用Python Python XML解析 Python XML生成 print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： >>> print('The quick brown fox', 'jumps over', 'the lazy dog') The quick brown fox jumps over the lazy dog print()会依次打印每个字符串，遇到逗号“,”会输出一个空格。 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义。 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容。 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： >>> t = (1,) >>> t (1,) Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： >>> list(range(5)) [0, 1, 2, 3, 4] 在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为dict的key。 赋值语句 a, b = b, a + b 相当于 t = (b, a + b) # t是一个tuple a = t[0] b = t[1] Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/其他/vscode-cmake.html":{"url":"Body/其他/vscode-cmake.html","title":"vscode-cmake","keywords":"","body":"launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", // Resolved by CMake Tools: \"program\": \"${command:cmake.launchTargetPath}\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [ { // add the directory where our target was built to the PATHs // it gets resolved by CMake Tools: \"name\": \"PATH\", \"value\": \"${env:PATH}:${command:cmake.getLaunchTargetDirectory}\" }, { \"name\": \"OTHER_VALUE\", \"value\": \"Something something\" } ], \"externalConsole\": true, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ] } ] } Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-11-13 20:34:28 "},"Body/其他/Git.html":{"url":"Body/其他/Git.html","title":"Git","keywords":"","body":"Git git教程 gitflow工作流 怎样使用 GitHub？ Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "},"Body/其他/GitHub资源.html":{"url":"Body/其他/GitHub资源.html","title":"GitHub资源","keywords":"","body":"GitHub资源 正则表达式 Copyright © Ryou 2021 all right reserved，powered by Gitbook最后修改时间： 2021-08-01 19:24:58 "}}