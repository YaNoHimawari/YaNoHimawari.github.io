{"./":{"url":"./","title":"序","keywords":"","body":"序 名称：《1024》 作者：YaNoHimawari 内容： 本书为个人对所学所用的编程知识及技能总结归纳的成果。 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:39:52 "},"Body/理论/计算机网络/基础.html":{"url":"Body/理论/计算机网络/基础.html","title":"计算机网络","keywords":"","body":"基础 计算机网络基础知识 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2020-09-13 16:25:28 "},"Body/C&C++/基础/基础.html":{"url":"Body/C&C++/基础/基础.html","title":"基础","keywords":"","body":"基础 内置基本类型 左值、右值、左值引用、右值引用 static成员的初始化和特点 静态局部变量只对定义它的函数体始终可见，函数体执行完后虽然还存在，但无法被其他的使用。 class默认的是private继承。struct则相反，默认的是public继承。 宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响。 对变量声明一个引用，并不另开辟内存单元，x和y都代表相同一变量存储单元。在声明一个引用时，必须同时使之初始化。在函数中声明一个变量的引用后，在函数执行期间，该引用一直与其代表的变量相联系，不能再作为其他变量的别名。 常引用就是用const对引用加以限定，表示不允许改变该引用的值。例如： int a = 6; // 定义整型变量a，初值为6 const int &b = a; // 声明常引用，不允许改变b的值 b = 8; // 改变常引用b的值，错误 a = 8; // 改变a的值，正确 enum枚举量声明、定义、使用 未定义行为 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:02:25 "},"Body/C&C++/基础/数组.html":{"url":"Body/C&C++/基础/数组.html","title":"数组","keywords":"","body":"数组 数组名代表被分配的内存首地址，是一个地址常量，不能作为左值，无法进行赋值。 数组引用 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 14:53:09 "},"Body/C&C++/基础/运算符.html":{"url":"Body/C&C++/基础/运算符.html","title":"运算符","keywords":"","body":"运算符 只能使用成员函数重载的运算符有：=、()、[]、->、new、delete。 运算符重载 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 14:55:31 "},"Body/C&C++/基础/函数.html":{"url":"Body/C&C++/基础/函数.html","title":"函数","keywords":"","body":"函数 函数的隐含储存类型是extern，函数的形参或变量的存储类型为auto。 C++允许给形参提供默认值，默认参数应在函数名第一次出现时指定。默认参数必须是函数参数表中最右边(尾部)的参数。 std::function和std::bind 标准C++ 要求main()函数必须声明为int型。有的操作系统(如Linux)要求执行一个程序后必须向操作系统返回一个数值。但有些C++ 编译系统并未完全执行C++这一规定，如主函数首行写成“void main()”也能通过。 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 14:59:14 "},"Body/C&C++/基础/指针.html":{"url":"Body/C&C++/基础/指针.html","title":"指针","keywords":"","body":"指针 智能指针 自定义删除器 不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr。 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:00:39 "},"Body/C&C++/基础/类.html":{"url":"Body/C&C++/基础/类.html","title":"类","keywords":"","body":"类 用关键字const来声明常数据成员。常数据成员只能通过构造函数的参数初始化表进行初始化。 常对象只能调用常成员函数，非常对象既可以调用非常成员函数，也可以调用常成员函数。 在类内可以直接访问所有的静态数据成员，类的静态数据成员必须在类外进行初始化，初始化方式为： 类型名 类名::静态数据成员名 = 初始值; 虚基类的构造函数先于非虚基类的构造函数执行。 指针指向一个具体对象后，不能通过指针直接或间接调用构造函数，所以C++还规定构造函数也不能声明为虚函数。 如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都是有默认值，则此构造函数是拷贝构造函数。 虚函数与析构函数 #include using namespace std; class M{ public: M(){cout 类的继承 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2020-09-13 15:23:16 "},"Body/C&C++/进阶/I&O.html":{"url":"Body/C&C++/进阶/I&O.html","title":"进阶","keywords":"","body":"I/O 调用python //初始化python Py_Initialize（）； if（！Py_IsInitialized（）) { return; } PyRun_SimpleString(“import sys”); PyRun_SimpleString(“sys.path.append(‘.’)”); PyObject* pModule = PyImport_ImportModule(“模块名称”); if(!pModule) { return; } PyObject* pFunc = PyObject_GetAttrString(pModule,”方法名称”); if(!pFunc) { return; } /* s 表示字符串 i 表示整型变量 f 表示浮点变量 o 表示python对象 */ PyObject* pArgs = PyTuple_New(2); PyTuple_SetItem(pArgs, 0, Py_BuildValue(“s”, “参数1”.toStdString().c_str())); PyTuple_SetItem(pArgs, 1, Py_BuildValue(“s”, “参数2”.toStdString().c_str())); PyObject* object = PyObject_Callobject(pFunc, pArgs); int result = -1; PyArg_Parse(object, “i”, &result); //转化调用结果 //结束，释放python Py_Finalize(); ini文件 QSettings configIni(“文件名.ini”, QSettings::IniFrmat); //读 QString value = configIni.value(“组名/属性名”).toString(); //写 configIni.beginGroup(“组名”); configIni.setValue(“属性名”, 属性值); xml文件 #include #include 解析xml QFile xmlFile(“文件名”); if(!xmlFile.exists()) { return false; } if(!xmlFile.open(QFile::ReadOnly)) { return false; } QDomDocument doc; if(!doc.setContent(&xmlFile)) { return false; } QDomElement root = doc.documentElement(); if(root.tagName() != “一级节点名称”) { return false; } QDomNode node = root.firstChild(); if(node.isNull) { return false; } QDomNode childNode = node.firstChild(); //访问子节点 QDomNode siblingNode = node.nextSibling(); //访问同级节点 QString tagName = node.toElement().tagName(); //当前节点名称 QString text = node.toElement().text(); //当前节点文本内容 QString attributeValue = node.toElement().attribute(“属性名”); //当前节点属性值 xmlFile.close(); 生成xml QDomDocument doc; //设置前缀 QString strHeader(”version=\\”1.0\\” encoding=\\”UTF-8\\””); doc.appendChild(doc.createProcessingInstruction(“xml”, strHeader)); QDomElement element = doc.createElement(“节点名称”); //创建的节点名称 element.setAttribbute(“属性名”, 属性值(字符串)); //设置节点属性 QDomText text = doc.createTextNode(“文本内容”); //设置文本内容 element.appendChild(text); doc.appendChild(element); //连接子节点 QFile file(“文件名”); if(!file.open(QIODevice::WriteOnly)) { return false; } QTextstream stream(&file); doc.save(stream, 4); file.close(); dll文件 #include 生成dll #ifndef 文件名_EXPORTS #define 文件名_EXPORTS __declspec(dllexport) #endif #ifdef __cplusplus extern “C” { #endif ... #ifdef __cplusplus } #endif 动态调用 typedef 返回类型 (*PtrFunc)(参数); HMODULE hDll = LoadLibrary(L”文件名.dll”); if(hDll != NULL) { PtrFunc pFunc = (PtrFunc)GetProcAddress(hDll, “方法名”); if(pFunc != NULL) { pFunc(参数); } } Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:39:05 "},"Body/C&C++/进阶/拓展.html":{"url":"Body/C&C++/进阶/拓展.html","title":"拓展","keywords":"","body":"拓展 lambda表达式 tr1::function Google C++ 编码规范 C++面试常见问题 C++ Socket编程 C++高级特性介绍 位运算 框架与库 避免内存泄漏 C++资源 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-10-27 20:02:23 "},"Body/C&C++/算法/基础.html":{"url":"Body/C&C++/算法/基础.html","title":"算法","keywords":"","body":"基础 数据结构和算法动态可视化 经典排序算法 堆排序 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:07:07 "},"Body/C&C++/算法/冒泡排序.html":{"url":"Body/C&C++/算法/冒泡排序.html","title":"冒泡排序","keywords":"","body":"冒泡排序 template bool up(T a, T b) //a_rank b; } template bool down(T a, T b) { return a void bubble_sort(T array[], int lo, int hi, bool(*cmp)(T, T)) { int last = hi; for(bool sorted = false;sorted = !sorted;hi = last) for (int i = lo+1; i Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:08:56 "},"Body/C&C++/Effective C++/Effective C++.html":{"url":"Body/C&C++/Effective C++/Effective C++.html","title":"Effective C++","keywords":"","body":"《Effective C++》 条款1 C++是个多重泛型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。 如果一个新对象被定义，一定会有个构造函数被调用，不可能调用赋值操作。例如A a1 = a2; 条款2 如果声明式中的变量是class专属常量又是static且为整数类型(int,char,bool)，只要不取地址，可以声明并使用它而无须提供定义式。例如类体中使用“static const int n = 5;”语句。 枚举类型在C#或C++,java,VB等一些计算机编程语言中是一种基本数据类型而不是构造数据类型，而在C语言等计算机编程语言中是一种构造数据类型。 条款3 void f1(const int n);与void f2(int const n)；意思是一样的。 迭代器中const的用法std::vector vec; ... const std::vector::iterator iter = vec.begin(); //iter的作用像个T* const *iter = 10; //没问题，改变iter所指物 ++iter; //错误！iter是const std::vector::const_iterator cIter = vec.begin(); //cIter的作用域像个const T* *cIter = 10; //错误！*cIter是const ++cIter; //没问题，改变cIter a =( c++,b++)；→ a = b; c++; b++; 按照运算符的优先级，先计算括号,也就是讨论c++,b++。然后计算++，也就是c和b分别自加。然后谈论逗号运算符，没有意义，就是从左到右。所以最后赋值给a的是b++。前面提到一个注意就是，虽然b自加了，但是他的写法是b++ 而不是++ b，意义上是先使用后自加。所以赋值给a的值是当前的b的值，这一行指令结束以后，b自身的值才会++。 mutable的用法 class CTextBlock{ public: ... size_t length() const; private: char* pText; mutable size_t textLength; //这些成员变量可能总是会被更改，即使在const成员函数内 mutable bool lengthIsValid; }; size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = strlen(pText); //正确，允许值得修改 lengthIsValid = true; } return textLength; } 条款4 比起先调用default构造函数再调用赋值操作，单只调用一次赋值构造函数更加高效。对于内置型对象，其初始化和赋值成本相同，但为了一致性最好也通过成员初值列来初始化。 条款5 C++不允许让引用改指向不同对象。 内含引用成员或const成员的类，必须自己定义赋值运算符。 如果某个父类将赋值运算符声明为private，编译器将拒绝自动为其子类生成赋值运算符。 条款6 为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。或者继承像uncopyable这样的父类也是一种做法。 条款7 如果类中含有virtual函数，其对象的体积会增加，并且不再具有移植性。 所有的stl容器都不带virtual函数，不应该被其他类继承。 可以通过将析构函数声明为纯虚函数的方式创建抽象类，但必须为纯虚析构函数提供一份定义。 条款8 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或结束程序。 条款9 在构造和析构期间不要调用virtual函数，因为此时子类还未初始化，只会错误地执行父类的virtual函数。 条款10 重载赋值运算符时最好返回*this的引用。 条款11 使用证同测试来处理自我赋值。 if (this == rhs) return *this; 条款12 子类调用父类赋值运算符操作的语句。 BaseClassName::operator=(rhs); 如果复制构造函数和重载赋值运算符有相近的代码，可以建立一个新的成员函数被两者调用以消除重复代码。这样的函数往往是private而且常被命名为init。 条款13 为防止资源泄漏，以对象管理资源，资源取得时机便是初始化时机。比如使用智能指针管理动态分配的内存。 智能指针 条款14 shared_ptr允许指定所谓的删除器，那是一个函数或函数对象，当引用次数为0时被调用。删除器是可有可无的第二参数。 智能指针删除器 函数指针 条款15 operator隐式类型转换 条款16 尽量不要对动态数组做typedef操作。typedef string s[4]; string * ps = new s; //等于new s[4] delete [] ps; //以数组方式delete 条款17 C++不以特定次序完成函数参数的核算。 用独立语句将新建对象放入智能指针内，可以防止难以察觉的资源泄露出现。 条款18 阻止接口误用的方法包括建立新类型，限制类型上的操作，束缚对象值以及消除客户的资源管理责任（自动管理资源）。 条款19 类设计时应该考虑的问题。 条款20 以引用的方式传递参数可以避免对象切割问题。 对于内置类型，传值比传引用效率更高。 条款21 对于临时对象或new生成的对象，不应该返回其引用。 条款22 private才能实现类的封装性。 protected并不比public更具封装性。 条款23 用非成员函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性。 条款24 如果某个函数所有参数（包括被this指针所指的那个隐喻参数）都可能进行类型转换，则应该将这个函数设置为非成员函数。 条款25 C++只允许对类模板偏特化，函数模板不允许偏特化。 可以全特化std内的模板，但不可以添加新的模板（或类或方法或其他）到std里面。 条款26 除非赋值成本比“构造+析构”成本低，不然将临时变量定义于循环内效率更高。 条款27 旧式转型(类型)表达式 //c风格 类型(表达式) //函数风格 新式转型const_cast(表达式) //移除对象的const属性 dynamic_cast(表达式) //决定某对象是否归属继承体系中的某个类型，耗费重大运行成本 reinterpret_cast(表达式) //执行低级转型，如将int指针转为int，不可移植 static_cast(表达式) //强迫隐式转换，如将非常量转为常量，int转为double等。但无法将const属性移除 编程尽量避免转型。如果必要，最好使用新式转型，不要使用旧式转型。 条款28 避免返回指向对象内部的引用，指针以及迭代器，这能增加封装性，防止所指资源被意外释放。 条款29 强烈异常安全保证的函数往往能通过拷贝加交换的形式实现，但为此付出的效率代价也值得考虑。 函数的异常安全等级通常只等于其调用的各个函数中最弱的那一个。 条款30 类内定义的成员函数与友元函数，都被隐喻声明为inline。 所有virtual函数都不支持inline。 inline的本质是对此函数的每一个调用都以函数本体替换之。 条款31 头文件一旦修改，所有包含该头文件的代码文件都会重新编译。 编译依存性最小化的两种方法： 将类分割成两部分，一部分提供接口，一部分负责具体实现。 使用纯虚函数将类定义为抽象基类。 条款32 pulic继承等同于“是一个”概念。适用基类的操作一定也适用于此方法继承的子类。 条款33 子类的变量，函数名会掩盖基类中的相同名称成员。基类中的多个重载函数会全部被子类同名成员覆盖。 使用using可以让子类访问到被覆盖的基类成员函数。 条款34 C++允许为纯虚函数提供定义，但调用它的唯一途径是“调用时你明确指出其类名”。 虚函数在子类中允许缺省，纯虚函数在子类中必须重新定义。 条款35 Private类型虚函数 条款36 绝对不要重新定义继承而来的非虚函数。 条款37 绝对不要重新定义一个继承而来的缺省参数值。 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:47:00 "},"Body/Linux/Linux.html":{"url":"Body/Linux/Linux.html","title":"Linux","keywords":"","body":"Linux linux命令大全 gdb教程 vim命令 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:17:11 "},"Body/Python/Python.html":{"url":"Body/Python/Python.html","title":"Python","keywords":"","body":"Python C++调用Python Python XML解析 Python XML生成 print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： >>> print('The quick brown fox', 'jumps over', 'the lazy dog') The quick brown fox jumps over the lazy dog print()会依次打印每个字符串，遇到逗号“,”会输出一个空格。 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义。 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容。 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： >>> t = (1,) >>> t (1,) Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： >>> list(range(5)) [0, 1, 2, 3, 4] 在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为dict的key。 赋值语句 a, b = b, a + b 相当于 t = (b, a + b) # t是一个tuple a = t[0] b = t[1] Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:19:08 "},"Body/Python/多线程.html":{"url":"Body/Python/多线程.html","title":"多线程","keywords":"","body":"Python多线程 threading 模块 普通创建方式 import threading import time def run(n): print(\"task\", n) time.sleep(1) print('2s') time.sleep(1) print('1s') time.sleep(1) print('0s') time.sleep(1) if __name__ == '__main__': t1 = threading.Thread(target=run, args=(\"t1\",)) t2 = threading.Thread(target=run, args=(\"t2\",)) t1.start() t2.start() ---------------------------------- >>> task t1 >>> task t2 >>> 2s >>> 2s >>> 1s >>> 1s >>> 0s >>> 0s 自定义线程 继承 threading.Thread 来自定义线程类，其本质是重构 Thread 类中的 run 方法 import threading import time class MyThread(threading.Thread): def __init__(self, n): super(MyThread, self).__init__() # 重构run函数必须要写 self.n = n def run(self): print(\"task\", self.n) time.sleep(1) print('2s') time.sleep(1) print('1s') time.sleep(1) print('0s') time.sleep(1) if __name__ == \"__main__\": t1 = MyThread(\"t1\") t2 = MyThread(\"t2\") t1.start() t2.start() ---------------------------------- >>> task t1 >>> task t2 >>> 2s >>> 2s >>> 1s >>> 1s >>> 0s >>> 0s 守护线程 我们看下面这个例子，这里使用 setDaemon(True) 把所有的子线程都变成了主线程的守护线程，因此当主进程结束后，子线程也会随之结束。所以当主线程结束后，整个程序就退出了。 import threading import time def run(n): print(\"task\", n) time.sleep(1) #此时子线程停1s print('3') time.sleep(1) print('2') time.sleep(1) print('1') if __name__ == '__main__': t = threading.Thread(target=run, args=(\"t1\",)) t.setDaemon(True) #把子进程设置为守护线程，必须在start()之前设置 t.start() print(\"end\") ---------------------------------- >>> task t1 >>> end 我们可以发现，设置守护线程之后，当主线程结束时，子线程也将立即结束，不再执行。 主线程等待子线程结束 为了让守护线程执行结束之后，主线程再结束，我们可以使用 join 方法，让主线程等待子线程执行。 import threading import time def run(n): print(\"task\", n) time.sleep(1) #此时子线程停1s print('3') time.sleep(1) print('2') time.sleep(1) print('1') if __name__ == '__main__': t = threading.Thread(target=run, args=(\"t1\",)) t.setDaemon(True) #把子进程设置为守护线程，必须在start()之前设置 t.start() t.join() # 设置主线程等待子线程结束 print(\"end\") ---------------------------------- >>> task t1 >>> 3 >>> 2 >>> 1 >>> end 多线程共享全局变量 线程是进程的执行单元，进程是系统分配资源的最小单位，所以在同一个进程中的多线程是共享资源的。 import threading import time g_num = 100 def work1(): global g_num for i in range(3): g_num += 1 print(\"in work1 g_num is : %d\" % g_num) def work2(): global g_num print(\"in work2 g_num is : %d\" % g_num) if __name__ == '__main__': t1 = threading.Thread(target=work1) t1.start() time.sleep(1) t2 = threading.Thread(target=work2) t2.start() ---------------------------------- >>> in work1 g_num is : 103 >>> in work2 g_num is : 103 互斥锁 由于线程之间是进行随机调度，并且每个线程可能只执行 n 条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，所以，出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，你可以定义多个锁, 像下面的代码, 当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理。 由于线程之间是进行随机调度，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，我们也称此为 “线程不安全”。 为了方式上面情况的发生，就出现了互斥锁 (Lock) from threading import Thread,Lock import os,time def work(): global n lock.acquire() temp=n time.sleep(0.1) n=temp-1 lock.release() if __name__ == '__main__': lock=Lock() n=100 l=[] for i in range(100): p=Thread(target=work) l.append(p) p.start() for p in l: p.join() 递归锁 RLcok 类的用法和 Lock 类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用 RLcok 类。 import threading import time def Func(lock): global gl_num lock.acquire() gl_num += 1 time.sleep(1) print(gl_num) lock.release() if __name__ == '__main__': gl_num = 0 lock = threading.RLock() for i in range(10): t = threading.Thread(target=Func, args=(lock,)) t.start() 信号量（BoundedSemaphore 类) 互斥锁同时只允许一个线程更改数据，而 Semaphore 是同时允许一定数量的线程更改数据 ，比如厕所有 3 个坑，那最多只允许 3 个人上厕所，后面的人只能等里面有人出来了才能再进去。 import threading import time def run(n, semaphore): semaphore.acquire() #加锁 time.sleep(1) print(\"run the thread:%s\\n\" % n) semaphore.release() #释放 if __name__ == '__main__': num = 0 semaphore = threading.BoundedSemaphore(5) # 最多允许5个线程同时运行 for i in range(22): t = threading.Thread(target=run, args=(\"t-%s\" % i, semaphore)) t.start() while threading.active_count() != 1: pass # print threading.active_count() else: print('-----all threads done-----') 事件（Event 类） python 线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下几个方法： clear 将 flag 设置为 “False” set 将 flag 设置为 “True” is_set 判断是否设置了 flag wait 会一直监听 flag，如果没有检测到 flag 就一直处于阻塞状态 事件处理的机制：全局定义了一个 “Flag”，当 flag 值为“False”，那么 event.wait() 就会阻塞，当 flag 值为 “True”，那么 event.wait() 便不再阻塞。 #利用Event类模拟红绿灯 import threading import time event = threading.Event() def lighter(): count = 0 event.set() #初始值为绿灯 while True: if 5 10: event.set() # 绿灯，设置标志位 count = 0 else: print(\"1mgreen light is on...\") time.sleep(1) count += 1 def car(name): while True: if event.is_set(): #判断是否设置了标志位 print(\"[%s] running...\"%name) time.sleep(1) else: print(\"[%s] sees red light,waiting...\"%name) event.wait() print(\"[%s] green light is on,start going...\"%name) light = threading.Thread(target=lighter,) light.start() car = threading.Thread(target=car,args=(\"MINI\",)) car.start() GIL（Global Interpreter Lock）全局解释器锁 在非 python 环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在 python 中，无论有多少核，同时只能执行一个线程。究其原因，这就是由于 GIL 的存在导致的。 GIL 的全称是 Global Interpreter Lock(全局解释器锁)，来源是 python 设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是 “通行证”，并且在一个 python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。GIL 只在 cpython 中才有，因为 cpython 调用的是 c 语言的原生线程，所以他不能直接操作 cpu，只能利用 GIL 保证同一时间只能有一个线程拿到数据。而在 pypy 和 jpython 中是没有 GIL 的。 Python 多线程的工作过程：python 在使用多线程的时候，调用的是 c 语言的原生线程。 拿到公共数据 申请 gil python 解释器调用 os 原生线程 os 操作 cpu 执行运算 当该线程执行时间到后，无论运算是否已经执行完，gil 都被要求释放 进而由其他进程重复上面的过程 等其他进程执行完后，又会切换到之前的线程（从他记录的上下文继续执行），整个过程是每个线程执行自己的运算，当执行时间到就进行切换（context switch）。 python 针对不同类型的代码执行效率也是不同的： 1、CPU 密集型代码 (各种循环处理、计算等等)，在这种情况下，由于计算工作多，ticks 计数很快就会达到阈值，然后触发 GIL 的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以 python 下的多线程对 CPU 密集型代码并不友好。 2、IO 密集型代码 (文件处理、网络爬虫等涉及文件读写的操作)，多线程能够有效提升效率 (单线程下有 IO 操作会进行 IO 等待，造成不必要的时间浪费，而开启多线程能在线程 A 等待时，自动切换到线程 B，可以不浪费 CPU 的资源，从而能提升程序执行效率)。所以 python 的多线程对 IO 密集型代码比较友好。 使用建议？ python 下想要充分利用多核 CPU，就用多进程。因为每个进程有各自独立的 GIL，互不干扰，这样就可以真正意义上的并行执行，在 python 中，多进程的执行效率优于多线程 (仅仅针对多核 CPU 而言)。 GIL 在 python 中的版本差异： 1、在 python2.x 里，GIL 的释放逻辑是当前线程遇见 IO 操作或者 ticks 计数达到 100 时进行释放。（ticks 可以看作是 python 自身的一个计数器，专门做用于 GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整）。而每次释放 GIL 锁，线程进行锁竞争、切换线程，会消耗资源。并且由于 GIL 锁存在，python 里一个进程永远只能同时执行一个线程 (拿到 GIL 的线程才能执行)，这就是为什么在多核 CPU 上，python 的多线程效率并不高。2、在 python3.x 中，GIL 不使用 ticks 计数，改为使用计时器（执行时间达到阈值后，当前线程释放 GIL），这样对 CPU 密集型程序更加友好，但依然没有解决 GIL 导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2020-09-14 22:11:36 "},"Body/其他/Git.html":{"url":"Body/其他/Git.html","title":"Git","keywords":"","body":"Git git教程 gitflow工作流 怎样使用 GitHub？ Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:11:46 "},"Body/其他/GitHub资源.html":{"url":"Body/其他/GitHub资源.html","title":"GitHub资源","keywords":"","body":"GitHub资源 正则表达式 Copyright © YaNoHimawari all right reserved，powered by Gitbook最后修改时间： 2019-10-27 20:12:58 "}}