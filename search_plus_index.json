{"./":{"url":"./","title":"序","keywords":"","body":"序 名称：《1024》 作者：YaNoHimawari 内容： 本书为个人对所学所用的编程知识及技能总结归纳的成果。 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:39:52 "},"C&C++/基础.html":{"url":"C&C++/基础.html","title":"C/C++","keywords":"","body":"基础 内置基本类型 左值、右值、左值引用、右值引用 static成员的初始化和特点 静态局部变量只对定义它的函数体始终可见，函数体执行完后虽然还存在，但无法被其他的使用。 class默认的是private继承。struct则相反，默认的是public继承。 宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响。 对变量声明一个引用，并不另开辟内存单元，x和y都代表相同一变量存储单元。在声明一个引用时，必须同时使之初始化。在函数中声明一个变量的引用后，在函数执行期间，该引用一直与其代表的变量相联系，不能再作为其他变量的别名。 常引用就是用const对引用加以限定，表示不允许改变该引用的值。例如： int a = 6; // 定义整型变量a，初值为6 const int &b = a; // 声明常引用，不允许改变b的值 b = 8; // 改变常引用b的值，错误 a = 8; // 改变a的值，正确 enum枚举量声明、定义、使用 未定义行为 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:02:25 "},"C&C++/数组.html":{"url":"C&C++/数组.html","title":"数组","keywords":"","body":"数组 数组名代表被分配的内存首地址，是一个地址常量，不能作为左值，无法进行赋值。 数组引用 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 14:53:09 "},"C&C++/运算符.html":{"url":"C&C++/运算符.html","title":"运算符","keywords":"","body":"运算符 只能使用成员函数重载的运算符有：=、()、[]、->、new、delete。 运算符重载 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 14:55:31 "},"C&C++/函数.html":{"url":"C&C++/函数.html","title":"函数","keywords":"","body":"函数 函数的隐含储存类型是extern，函数的形参或变量的存储类型为auto。 C++允许给形参提供默认值，默认参数应在函数名第一次出现时指定。默认参数必须是函数参数表中最右边(尾部)的参数。 std::function和std::bind 标准C++ 要求main()函数必须声明为int型。有的操作系统(如Linux)要求执行一个程序后必须向操作系统返回一个数值。但有些C++ 编译系统并未完全执行C++这一规定，如主函数首行写成“void main()”也能通过。 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 14:59:14 "},"C&C++/指针.html":{"url":"C&C++/指针.html","title":"指针","keywords":"","body":"指针 智能指针 自定义删除器 不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr。 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:00:39 "},"C&C++/类.html":{"url":"C&C++/类.html","title":"类","keywords":"","body":"类 用关键字const来声明常数据成员。常数据成员只能通过构造函数的参数初始化表进行初始化。 常对象只能调用常成员函数，非常对象既可以调用非常成员函数，也可以调用常成员函数。 在类内可以直接访问所有的静态数据成员，类的静态数据成员必须在类外进行初始化，初始化方式为： 类型名 类名::静态数据成员名 = 初始值; 虚基类的构造函数先于非虚基类的构造函数执行。 指针指向一个具体对象后，不能通过指针直接或间接调用构造函数，所以C++还规定构造函数也不能声明为虚函数。 如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都是有默认值，则此构造函数是拷贝构造函数。 虚函数与析构函数 #include using namespace std; class M{ public: M(){cout Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:51:56 "},"C&C++/I&O.html":{"url":"C&C++/I&O.html","title":"I/O","keywords":"","body":"I/O 调用python //初始化python Py_Initialize（）； if（！Py_IsInitialized（）) { return; } PyRun_SimpleString(“import sys”); PyRun_SimpleString(“sys.path.append(‘.’)”); PyObject* pModule = PyImport_ImportModule(“模块名称”); if(!pModule) { return; } PyObject* pFunc = PyObject_GetAttrString(pModule,”方法名称”); if(!pFunc) { return; } /* s 表示字符串 i 表示整型变量 f 表示浮点变量 o 表示python对象 */ PyObject* pArgs = PyTuple_New(2); PyTuple_SetItem(pArgs, 0, Py_BuildValue(“s”, “参数1”.toStdString().c_str())); PyTuple_SetItem(pArgs, 1, Py_BuildValue(“s”, “参数2”.toStdString().c_str())); PyObject* object = PyObject_Callobject(pFunc, pArgs); int result = -1; PyArg_Parse(object, “i”, &result); //转化调用结果 //结束，释放python Py_Finalize(); ini文件 QSettings configIni(“文件名.ini”, QSettings::IniFrmat); //读 QString value = configIni.value(“组名/属性名”).toString(); //写 configIni.beginGroup(“组名”); configIni.setValue(“属性名”, 属性值); xml文件 #include #include 解析xml QFile xmlFile(“文件名”); if(!xmlFile.exists()) { return false; } if(!xmlFile.open(QFile::ReadOnly)) { return false; } QDomDocument doc; if(!doc.setContent(&xmlFile)) { return false; } QDomElement root = doc.documentElement(); if(root.tagName() != “一级节点名称”) { return false; } QDomNode node = root.firstChild(); if(node.isNull) { return false; } QDomNode childNode = node.firstChild(); //访问子节点 QDomNode siblingNode = node.nextSibling(); //访问同级节点 QString tagName = node.toElement().tagName(); //当前节点名称 QString text = node.toElement().text(); //当前节点文本内容 QString attributeValue = node.toElement().attribute(“属性名”); //当前节点属性值 xmlFile.close(); 生成xml QDomDocument doc; //设置前缀 QString strHeader(”version=\\”1.0\\” encoding=\\”UTF-8\\””); doc.appendChild(doc.createProcessingInstruction(“xml”, strHeader)); QDomElement element = doc.createElement(“节点名称”); //创建的节点名称 element.setAttribbute(“属性名”, 属性值(字符串)); //设置节点属性 QDomText text = doc.createTextNode(“文本内容”); //设置文本内容 element.appendChild(text); doc.appendChild(element); //连接子节点 QFile file(“文件名”); if(!file.open(QIODevice::WriteOnly)) { return false; } QTextstream stream(&file); doc.save(stream, 4); file.close(); dll文件 #include 生成dll #ifndef 文件名_EXPORTS #define 文件名_EXPORTS __declspec(dllexport) #endif #ifdef __cplusplus extern “C” { #endif ... #ifdef __cplusplus } #endif 动态调用 typedef 返回类型 (*PtrFunc)(参数); HMODULE hDll = LoadLibrary(L”文件名.dll”); if(hDll != NULL) { PtrFunc pFunc = (PtrFunc)GetProcAddress(hDll, “方法名”); if(pFunc != NULL) { pFunc(参数); } } Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:39:05 "},"C&C++/拓展.html":{"url":"C&C++/拓展.html","title":"拓展","keywords":"","body":"拓展 lambda表达式 tr1::function Google C++ 编码规范 C++面试常见问题 C++ Socket编程 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:56:57 "},"C&C++/Effective C++.html":{"url":"C&C++/Effective C++.html","title":"Effective C++","keywords":"","body":"《Effective C++》 条款1 C++是个多重泛型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。 如果一个新对象被定义，一定会有个构造函数被调用，不可能调用赋值操作。例如A a1 = a2; 条款2 如果声明式中的变量是class专属常量又是static且为整数类型(int,char,bool)，只要不取地址，可以声明并使用它而无须提供定义式。例如类体中使用“static const int n = 5;”语句。 枚举类型在C#或C++,java,VB等一些计算机编程语言中是一种基本数据类型而不是构造数据类型，而在C语言等计算机编程语言中是一种构造数据类型。 条款3 void f1(const int n);与void f2(int const n)；意思是一样的。 迭代器中const的用法std::vector vec; ... const std::vector::iterator iter = vec.begin(); //iter的作用像个T* const *iter = 10; //没问题，改变iter所指物 ++iter; //错误！iter是const std::vector::const_iterator cIter = vec.begin(); //cIter的作用域像个const T* *cIter = 10; //错误！*cIter是const ++cIter; //没问题，改变cIter a =( c++,b++)；→ a = b; c++; b++; 按照运算符的优先级，先计算括号,也就是讨论c++,b++。然后计算++，也就是c和b分别自加。然后谈论逗号运算符，没有意义，就是从左到右。所以最后赋值给a的是b++。前面提到一个注意就是，虽然b自加了，但是他的写法是b++ 而不是++ b，意义上是先使用后自加。所以赋值给a的值是当前的b的值，这一行指令结束以后，b自身的值才会++。 mutable的用法 class CTextBlock{ public: ... size_t length() const; private: char* pText; mutable size_t textLength; //这些成员变量可能总是会被更改，即使在const成员函数内 mutable bool lengthIsValid; }; size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = strlen(pText); //正确，允许值得修改 lengthIsValid = true; } return textLength; } 条款4 比起先调用default构造函数再调用赋值操作，单只调用一次赋值构造函数更加高效。对于内置型对象，其初始化和赋值成本相同，但为了一致性最好也通过成员初值列来初始化。 条款5 C++不允许让引用改指向不同对象。 内含引用成员或const成员的类，必须自己定义赋值运算符。 如果某个父类将赋值运算符声明为private，编译器将拒绝自动为其子类生成赋值运算符。 条款6 为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。或者继承像uncopyable这样的父类也是一种做法。 条款7 如果类中含有virtual函数，其对象的体积会增加，并且不再具有移植性。 所有的stl容器都不带virtual函数，不应该被其他类继承。 可以通过将析构函数声明为纯虚函数的方式创建抽象类，但必须为纯虚析构函数提供一份定义。 条款8 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或结束程序。 条款9 在构造和析构期间不要调用virtual函数，因为此时子类还未初始化，只会错误地执行父类的virtual函数。 条款10 重载赋值运算符时最好返回*this的引用。 条款11 使用证同测试来处理自我赋值。 if (this == rhs) return *this; 条款12 子类调用父类赋值运算符操作的语句。 BaseClassName::operator=(rhs); 如果复制构造函数和重载赋值运算符有相近的代码，可以建立一个新的成员函数被两者调用以消除重复代码。这样的函数往往是private而且常被命名为init。 条款13 为防止资源泄漏，以对象管理资源，资源取得时机便是初始化时机。比如使用智能指针管理动态分配的内存。 智能指针 条款14 shared_ptr允许指定所谓的删除器，那是一个函数或函数对象，当引用次数为0时被调用。删除器是可有可无的第二参数。 智能指针删除器 函数指针 条款15 operator隐式类型转换 条款16 尽量不要对动态数组做typedef操作。typedef string s[4]; string * ps = new s; //等于new s[4] delete [] ps; //以数组方式delete 条款17 C++不以特定次序完成函数参数的核算。 用独立语句将新建对象放入智能指针内，可以防止难以察觉的资源泄露出现。 条款18 阻止接口误用的方法包括建立新类型，限制类型上的操作，束缚对象值以及消除客户的资源管理责任（自动管理资源）。 条款19 类设计时应该考虑的问题。 条款20 以引用的方式传递参数可以避免对象切割问题。 对于内置类型，传值比传引用效率更高。 条款21 对于临时对象或new生成的对象，不应该返回其引用。 条款22 private才能实现类的封装性。 protected并不比public更具封装性。 条款23 用非成员函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性。 条款24 如果某个函数所有参数（包括被this指针所指的那个隐喻参数）都可能进行类型转换，则应该将这个函数设置为非成员函数。 条款25 C++只允许对类模板偏特化，函数模板不允许偏特化。 可以全特化std内的模板，但不可以添加新的模板（或类或方法或其他）到std里面。 条款26 除非赋值成本比“构造+析构”成本低，不然将临时变量定义于循环内效率更高。 条款27 旧式转型(类型)表达式 //c风格 类型(表达式) //函数风格 新式转型const_cast(表达式) //移除对象的const属性 dynamic_cast(表达式) //决定某对象是否归属继承体系中的某个类型，耗费重大运行成本 reinterpret_cast(表达式) //执行低级转型，如将int指针转为int，不可移植 static_cast(表达式) //强迫隐式转换，如将非常量转为常量，int转为double等。但无法将const属性移除 编程尽量避免转型。如果必要，最好使用新式转型，不要使用旧式转型。 条款28 避免返回指向对象内部的引用，指针以及迭代器，这能增加封装性，防止所指资源被意外释放。 条款29 强烈异常安全保证的函数往往能通过拷贝加交换的形式实现，但为此付出的效率代价也值得考虑。 函数的异常安全等级通常只等于其调用的各个函数中最弱的那一个。 条款30 类内定义的成员函数与友元函数，都被隐喻声明为inline。 所有virtual函数都不支持inline。 inline的本质是对此函数的每一个调用都以函数本体替换之。 条款31 头文件一旦修改，所有包含该头文件的代码文件都会重新编译。 编译依存性最小化的两种方法： 将类分割成两部分，一部分提供接口，一部分负责具体实现。 使用纯虚函数将类定义为抽象基类。 条款32 pulic继承等同于“是一个”概念。适用基类的操作一定也适用于此方法继承的子类。 条款33 子类的变量，函数名会掩盖基类中的相同名称成员。基类中的多个重载函数会全部被子类同名成员覆盖。 使用using可以让子类访问到被覆盖的基类成员函数。 条款34 C++允许为纯虚函数提供定义，但调用它的唯一途径是“调用时你明确指出其类名”。 虚函数在子类中允许缺省，纯虚函数在子类中必须重新定义。 条款35 Private类型虚函数 条款36 绝对不要重新定义继承而来的非虚函数。 条款37 绝对不要重新定义一个继承而来的缺省参数值。 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:47:00 "},"计算机网络/基础.html":{"url":"计算机网络/基础.html","title":"计算机网络","keywords":"","body":"基础 计算机网络基础知识 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 15:58:19 "},"算法/基础.html":{"url":"算法/基础.html","title":"算法","keywords":"","body":"基础 数据结构和算法动态可视化 经典排序算法 堆排序 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:07:07 "},"算法/冒泡排序.html":{"url":"算法/冒泡排序.html","title":"冒泡排序","keywords":"","body":"冒泡排序 template bool up(T a, T b) //a_rank b; } template bool down(T a, T b) { return a void bubble_sort(T array[], int lo, int hi, bool(*cmp)(T, T)) { int last = hi; for(bool sorted = false;sorted = !sorted;hi = last) for (int i = lo+1; i Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:08:56 "},"其他/Linux.html":{"url":"其他/Linux.html","title":"Linux","keywords":"","body":"Linux linux命令大全 gdb教程 vim命令 Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:17:11 "},"其他/Git.html":{"url":"其他/Git.html","title":"Git","keywords":"","body":"Git git教程 gitflow工作流 怎样使用 GitHub？ Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:11:46 "},"其他/Python.html":{"url":"其他/Python.html","title":"Python","keywords":"","body":"Python C++调用Python Python XML解析 Python XML生成 print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： >>> print('The quick brown fox', 'jumps over', 'the lazy dog') The quick brown fox jumps over the lazy dog print()会依次打印每个字符串，遇到逗号“,”会输出一个空格。 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义。 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容。 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： >>> t = (1,) >>> t (1,) Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： >>> list(range(5)) [0, 1, 2, 3, 4] 在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为dict的key。 赋值语句 a, b = b, a + b 相当于 t = (b, a + b) # t是一个tuple a = t[0] b = t[1] Copyright © YaNoHimawari 2019 all right reserved，powered by Gitbook最后修改时间： 2019-08-18 16:19:08 "}}